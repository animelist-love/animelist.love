function l(t){return{mutationKey:t.options.mutationKey,state:t.state}}function y(t){return{state:t.state,queryKey:t.queryKey,queryHash:t.queryHash}}function c(t){return t.state.isPaused}function d(t){return t.state.status==="success"}function q(t,e={}){const u=[],n=[];if(e.dehydrateMutations!==!1){const o=e.shouldDehydrateMutation||c;t.getMutationCache().getAll().forEach(a=>{o(a)&&u.push(l(a))})}if(e.dehydrateQueries!==!1){const o=e.shouldDehydrateQuery||d;t.getQueryCache().getAll().forEach(a=>{o(a)&&n.push(y(a))})}return{mutations:u,queries:n}}function K(t,e,u){if(typeof e!="object"||e===null)return;const n=t.getMutationCache(),o=t.getQueryCache(),a=e.mutations||[],f=e.queries||[];a.forEach(s=>{var r;n.build(t,{...u==null||(r=u.defaultOptions)==null?void 0:r.mutations,mutationKey:s.mutationKey},s.state)}),f.forEach(s=>{var r;const i=o.get(s.queryHash),h={...s.state,fetchStatus:"idle"};if(i){i.state.dataUpdatedAt<h.dataUpdatedAt&&i.setState(h);return}o.build(t,{...u==null||(r=u.defaultOptions)==null?void 0:r.queries,queryKey:s.queryKey,queryHash:s.queryHash},h)})}export{q as d,K as h};
